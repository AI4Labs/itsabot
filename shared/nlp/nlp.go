package nlp

import (
	"database/sql/driver"
	"encoding/csv"
	"errors"
	"fmt"
	"regexp"
	"strings"

	log "github.com/avabot/ava/Godeps/_workspace/src/github.com/Sirupsen/logrus"
	"github.com/avabot/ava/Godeps/_workspace/src/github.com/avabot/avabot/shared/datatypes"
	"github.com/avabot/ava/Godeps/_workspace/src/github.com/jbrukh/bayesian"
)

func Classify(c *bayesian.Classifier, s string) (*StructuredInput,
	string, bool, error) {
	si := &StructuredInput{}
	if len(s) == 0 {
		return si, "", false, ErrSentenceTooShort
	}
	ws := strings.Fields(s)
	var wc []WordClass
	var needsTraining bool
	var annotation string
	for i := range ws {
		var err error
		var tmp WordClass
		tmp, needsTraining, err = classifyTrigram(c, s, ws, i)
		if err != nil {
			return si, "", false, err
		}
		wc = append(wc, tmp)
		sym, err := bayesIntToSymbol(tmp.Class)
		if err != nil {
			return si, "", false, err
		}
		annotation += fmt.Sprintf("_%s(%s) ", sym, ws[i])
	}
	annotation = annotation[0 : len(annotation)-1]
	if err := si.Add(wc); err != nil {
		return si, "", false, err
	}
	return si, annotation, needsTraining, nil
}

// classifyTrigram determines the best classification for a word in a sentence
// given its surrounding context (i, i+1, i+2). Underflow on the returned
// probabilities is possible, but ignored, since classifyTrigram prefers a >=70%
// confidence level. The bool returned specified whether additional training is
// needed.
func classifyTrigram(c *bayesian.Classifier, s string, ws []string, i int) (
	WordClass, bool, error) {
	// TODO: Given the last 2 words of a sentence, construct the trigram
	// including prior words.
	var wc WordClass
	l := len(ws)
	word1, _, err := ExtractEntity(ws[i])
	if err != nil {
		return wc, false, err
	}
	bigram := word1
	trigram := word1
	var word2, word3 string
	if i+1 < l {
		word2, _, err = ExtractEntity(ws[i+1])
		if err != nil {
			return wc, false, err
		}
		bigram += " " + word2
		trigram += " " + word2
	}
	if i+2 < l {
		word3, _, err = ExtractEntity(ws[i+2])
		if err != nil {
			return wc, false, err
		}
		trigram += " " + word3
	}
	var needsTraining bool
	probs, likely, _ := c.ProbScores([]string{trigram})
	if max(probs) <= 0.7 {
		probs, likely, _ = c.ProbScores([]string{bigram})
		needsTraining = true
	}
	m := max(probs)
	if m <= 0.7 {
		probs, likely, _ = c.ProbScores([]string{word1})
		needsTraining = true
	}
	m = max(probs)
	if m <= 0.7 {
		log.WithFields(log.Fields{
			"fn":        "classifyTrigram",
			"word":      word1,
			"predicted": String[likely+1],
		}).Infoln("guessed word classification")
		needsTraining = true
	}
	return WordClass{word1, likely + 1}, needsTraining, nil
}

// StructuredInput is generated by Ava and sent to packages. The UserId is
// guaranteed to be unique. The FlexId is used for UserId lookups to maintain
// context, such as a phone number or email address.
type StructuredInput struct {
	Commands StringSlice
	Actors   StringSlice
	Objects  StringSlice
	Times    StringSlice
	Places   StringSlice
}

type WordClass struct {
	Word  string
	Class int
}

func (si *StructuredInput) String() string {
	s := "\n"
	if len(si.Commands) > 0 {
		s += "Command: " + strings.Join(si.Commands, ", ") + "\n"
	}
	if len(si.Actors) > 0 {
		s += "Actors: " + strings.Join(si.Actors, ", ") + "\n"
	}
	if len(si.Objects) > 0 {
		s += "Objects: " + strings.Join(si.Objects, ", ") + "\n"
	}
	if len(si.Times) > 0 {
		s += "Times: " + strings.Join(si.Times, ", ") + "\n"
	}
	if len(si.Places) > 0 {
		s += "Places: " + strings.Join(si.Places, ", ") + "\n"
	}
	return s[:len(s)-1] + "\n"
}

func (si *StructuredInput) All() string {
	var s string
	if len(si.Commands) > 0 {
		s += strings.Join(si.Commands, " ") + " "
	}
	if len(si.Actors) > 0 {
		s += strings.Join(si.Actors, " ") + " "
	}
	if len(si.Objects) > 0 {
		s += strings.Join(si.Objects, " ") + " "
	}
	if len(si.Times) > 0 {
		s += strings.Join(si.Times, " ") + " "
	}
	if len(si.Places) > 0 {
		s += strings.Join(si.Places, " ") + " "
	}
	if len(s) == 0 {
		return s
	}
	return s[0 : len(s)-1]
}

// Add pairs of words with their classes to a structured input. Params should
// follow the ("Order", "Command"), ("noon", "Time") form.
func (si *StructuredInput) Add(wc []WordClass) error {
	if len(wc) == 0 {
		return ErrInvalidOddParameter
	}
	for _, w := range wc {
		switch w.Class {
		case CommandI:
			si.Commands = append(si.Commands, w.Word)
		case ActorI:
			si.Actors = append(si.Actors, w.Word)
		case ObjectI:
			si.Objects = append(si.Objects, w.Word)
		case TimeI:
			si.Times = append(si.Times, w.Word)
		case PlaceI:
			si.Places = append(si.Places, w.Word)
		case NoneI:
			// Do nothing
		default:
			log.Println("invalid class: ", w.Class)
			return ErrInvalidClass
		}
	}
	return nil
}

// TODO Optimize by passing back a struct with []string AND int (ActorI,
// ObjectI, etc.)
func (si *StructuredInput) Pronouns() []string {
	p := []string{}
	for _, w := range si.Objects {
		if Pronouns[w] != 0 {
			p = append(p, w)
		}
	}
	for _, w := range si.Actors {
		if Pronouns[w] != 0 {
			p = append(p, w)
		}
	}
	for _, w := range si.Times {
		if Pronouns[w] != 0 {
			p = append(p, w)
		}
	}
	for _, w := range si.Places {
		if Pronouns[w] != 0 {
			p = append(p, w)
		}
	}
	return p
}

// StringSlice replaces []string, adding custom sql support for arrays in lieu
// of pq.
type StringSlice []string

// QuoteEscapeRegex replaces escaped quotes except if it is preceded by a
// literal backslash, e.g. "\\" should translate to a quoted element whose value
// is \
var QuoteEscapeRegex = regexp.MustCompile(`([^\\]([\\]{2})*)\\"`)

// Scan convert to a slice of strings
// http://www.postgresql.org/docs/9.1/static/arrays.html#ARRAYS-IO
func (s *StringSlice) Scan(src interface{}) error {
	asBytes, ok := src.([]byte)
	if !ok {
		return error(errors.New("scan source was not []bytes"))
	}
	str := string(asBytes)
	str = QuoteEscapeRegex.ReplaceAllString(str, `$1""`)
	str = strings.Replace(str, `\\`, `\`, -1)
	str = str[1 : len(str)-1]
	csvReader := csv.NewReader(strings.NewReader(str))
	slice, err := csvReader.Read()
	if err != nil && err.Error() != "EOF" {
		return err
	}
	*s = StringSlice(slice)
	return nil
}

func (s StringSlice) Value() (driver.Value, error) {
	// string escapes.
	// \ => \\\
	// " => \"
	for i, elem := range s {
		s[i] = `"` + strings.Replace(strings.Replace(elem, `\`, `\\\`, -1), `"`, `\"`, -1) + `"`
	}
	return "{" + strings.Join(s, ",") + "}", nil
}

// Last safely returns the last item in a StringSlice, which is most often the
// target of a pronoun, e.g. (In "Where is that?", "that" will most often refer
// to the last Object named in the previous sentence.
func (s StringSlice) Last() string {
	if len(s) == 0 {
		return ""
	}
	return s[len(s)-1]
}

func (s StringSlice) String() string {
	if len(s) == 0 {
		return ""
	}
	var ss string
	for _, w := range s {
		ss += " " + w
	}
	return ss[1:]
}

func (s StringSlice) StringSlice() []string {
	ss := []string{}
	for _, tmp := range s {
		if len(tmp) <= 2 {
			continue
		}
		ss = append(ss, tmp)
	}
	return ss
}

var (
	ErrInvalidClass        = errors.New("invalid class")
	ErrInvalidOddParameter = errors.New("parameter count must be even")
	ErrSentenceTooShort    = errors.New("sentence too short to classify")
)

const (
	CommandI int = iota + 1
	ActorI
	ObjectI
	TimeI
	PlaceI
	NoneI
	UnsureI
)

var String map[int]string = map[int]string{
	CommandI: "Command",
	ActorI:   "Actor",
	ObjectI:  "Object",
	TimeI:    "Time",
	PlaceI:   "Place",
	NoneI:    "None",
}

var Pronouns map[string]int = map[string]int{
	"me":    ActorI,
	"us":    ActorI,
	"you":   ActorI,
	"him":   ActorI,
	"her":   ActorI,
	"them":  ActorI,
	"it":    ObjectI,
	"that":  ObjectI,
	"there": PlaceI,
	"then":  TimeI,
}

func max(slice []float64) float64 {
	if len(slice) == 0 {
		return 0.0
	}
	m := slice[0]
	for index := 1; index < len(slice); index++ {
		if slice[index] > m {
			m = slice[index]
		}
	}
	return m
}

// ExtractEntity from a word. If a Command, strip any contraction. For example,
// "where's" -> where. Since Ava ignores linking verbs, there's no need to
// add "is" back into the sentence.
func ExtractEntity(w string) (string, bayesian.Class, error) {
	w = strings.TrimRight(w, ").,;?!:")
	if len(w) <= 1 {
		return w, "", nil
	}
	if w[0] != '_' {
		return w, "", nil
	}
	switch w[1] {
	case 'C':
		return w[3:], Command, nil
	case 'O':
		return w[3:], Object, nil
	case 'A':
		return w[3:], Actor, nil
	case 'T':
		return w[3:], Time, nil
	case 'P':
		return w[3:], Place, nil
	case 'N':
		return w[3:], None, nil
	case '?':
		return w[3:], Unsure, nil
	}
	return w, "", errors.New("syntax error in entity")
}

const (
	Command bayesian.Class = "Command"
	Actor   bayesian.Class = "Actor"
	Object  bayesian.Class = "Object"
	Time    bayesian.Class = "Time"
	Place   bayesian.Class = "Place"
	None    bayesian.Class = "None"
	Unsure  bayesian.Class = "Unsure"
)

func bayesIntToSymbol(c int) (string, error) {
	switch c {
	case dt.CommandI:
		return "C", nil
	case dt.ActorI:
		return "A", nil
	case dt.ObjectI:
		return "O", nil
	case dt.TimeI:
		return "T", nil
	case dt.PlaceI:
		return "P", nil
	case dt.NoneI:
		return "N", nil
	case dt.UnsureI:
		return "?", nil
	default:
		return "", errors.New("unrecognized class (converting to symbol)")
	}
}
